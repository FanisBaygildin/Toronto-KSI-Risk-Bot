# -*- coding: utf-8 -*-
"""telegram_bot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vyPPLE_QWFKWQtmMpbWrwhK11Ho_okVa
"""

from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters, ContextTypes, ConversationHandler

from google_maps_route import get_routes
from weather_api import build_weather_row
from route_risk import predict_risk

# Состояния для ConversationHandler
START_PC, END_PC, PERIOD = range(3)

user_data = {}

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Сообщение для первого запуска (при "пробуждении" на Render)
    await update.message.reply_text("⏳ Please wait... bot is waking up 💤")
    await update.message.reply_text("📍 Send postal code of the start point")
    return START_PC

async def receive_start_pc(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_data['start'] = update.message.text.strip()
    await update.message.reply_text("📍 Send postal code of the destination point")
    return END_PC

async def receive_end_pc(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_data['end'] = update.message.text.strip()

    # Предложим выбор периода
    keyboard = [["Следующие 3 ч", "Следующие 24 ч"]]
    reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True, resize_keyboard=True)
    await update.message.reply_text("⏰ На какой период?", reply_markup=reply_markup)
    return PERIOD

async def receive_period(update: Update, context: ContextTypes.DEFAULT_TYPE):
    period = update.message.text.strip()
    start = user_data['start']
    end = user_data['end']

    # Получение маршрута
    route = get_routes(start, end)

    # Получение погоды
    weather = build_weather_row()  # например, текущая погода (доработаешь под период)

    # Получение риска
    risk, city_avg = predict_risk(route, weather, period)  # возвращает риск и среднее по городу

    diff_percent = int(round((risk - city_avg) / city_avg * 100))

    if diff_percent > 0:
        comparison = f"higher than the city average by {diff_percent}%"
    elif diff_percent < 0:
        comparison = f"lower than the city average by {abs(diff_percent)}%"
    else:
        comparison = "equal to the city average"

    await update.message.reply_text(f"🚧 KSI Risk: {risk:.2f}‰ ({comparison})")

    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("Операция отменена.")
    return ConversationHandler.END

def start_bot():
    import os

    TOKEN = os.getenv("BOT_TOKEN")  # переменная окружения
    application = ApplicationBuilder().token(TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            START_PC: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_start_pc)],
            END_PC: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_end_pc)],
            PERIOD: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_period)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    application.add_handler(conv_handler)
    print("Бот запущен...")
    application.run_polling()
